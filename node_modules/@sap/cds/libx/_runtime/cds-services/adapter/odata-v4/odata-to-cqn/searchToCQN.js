const odata = require('../okra/odata-server')
const { BINARY, LITERAL, UNARY } = odata.uri.Expression.ExpressionKind
const { getFeatureNotSupportedError } = require('../../../util/errors')

const _getExpressionKindName = kind => {
  for (const key in odata.uri.Expression.ExpressionKind) {
    if (odata.uri.Expression.ExpressionKind[key] === kind) {
      return key
    }
  }

  return 'unknown'
}

const _searchRecursive = search => {
  switch (search.getKind()) {
    case BINARY: {
      const operator = search.getOperator().toLowerCase()
      const left = _searchRecursive(search.getLeftOperand())
      const right = _searchRecursive(search.getRightOperand())
      return [...left, operator, ...right]
    }
    case LITERAL:
      return [{ val: search.getText() }]
    case UNARY:
      return [search.getOperator(), { val: search.getOperand().getText() }]
    default:
      throw getFeatureNotSupportedError(`Search expression "${_getExpressionKindName(search.getKind())}"`)
  }
}

/**
 * Convert an OData search expression into a search CQN expression.
 *
 * @param {import('../okra/odata-commons/uri/Expression')} search - search expression
 * @throws Error in case of any other expressions than BINARY, UNARY and LITERAL
 * @returns {Array<object>} cqn - Partial cqn to be used as input param in .where or .and of SELECT
 */
const searchToCQN = search => {
  return _searchRecursive(search)
}

module.exports = searchToCQN
