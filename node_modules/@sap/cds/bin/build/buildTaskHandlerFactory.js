const { fs } = require('@sap/cds-foss')
const path = require('path')
const _cds = require('./cds')
const { BUILD_TASK_USE_PREFIX } = require("./constants")

const DEBUG = process.env.DEBUG

class BuildTaskHandlerFactory {
    constructor(logger, cds) {
        this._cds = cds ? cds : _cds
        this._logger = logger || global.console
    }
    get cds() {
        return this._cds
    }
    get env() {
        return this._cds.env
    }
    get logger() {
        return this._logger
    }

    /**
     * Create a BuildTaskHandler instance for the given build task.
     * The implementation is loaded based on the build task's 'for' or 'use' option.
     * @param {*} task
     * @param {*} buildOptions
     */
    createHandler(task, buildOptions) {
        const BuildTaskHandler = this.loadHandler(task)
        const resolvedTask = this.resolveTask(task, buildOptions)
        if (DEBUG) {
            this.logger.log(`[cds] - loaded BuildTaskHandler [${resolvedTask.use}]`)
        }

        const handler = new BuildTaskHandler()
        handler.task = resolvedTask
        handler.buildOptions = buildOptions
        handler.cds = this.cds
        handler.logger = this.logger
        if (DEBUG) {
            this.logger.log(`[cds] - created BuildTaskHandler [${resolvedTask.use}]`)
        }
        return handler
    }

    /**
     * Loads the build task handler implementation for the given build task.
     * 'for' defines an alias for built-in handlers like 'hana', 'java-cf', 'node-cf', 'fiori' or 'mtx'.
     * 'use' defines the fully qualified module name of external build task handler implemenations.
     * @param {*} task
     */
    loadHandler(task) {
        const modulePath = BuildTaskHandlerFactory._getModulePathFromTask(task)
        try {
            return module.parent.require(modulePath)
        }
        catch (e) {
            throw new Error(`Build task could not be resolved - module [${modulePath}] cannot be loaded:\n` + e)
        }
    }

    /**
     * Resolves the given build task based on the project root folder.<br>
     * The task is validated in order to ensure that 'src' refers to a valid folder and 'for' or 'use' reference can be required.
     * @param {*} task
     * @param {*} buildOptions
     */
    resolveTask(task, buildOptions) {
        // first validate handler implementation
        this.loadHandler(task)

        // second valdiate src path
        const resolvedTask = JSON.parse(JSON.stringify(task))
        if (!resolvedTask.use) {
            resolvedTask.use = BuildTaskHandlerFactory._getUseValueFromTask(resolvedTask)
        }
        if (!resolvedTask.for) {
            resolvedTask.for = BuildTaskHandlerFactory._getForValueFromTask(resolvedTask)
        }

        // Do not store resolved symlinks as this is causing issues on Windows, e.g. if git projects are
        // located under 'C:\SAPDevelop\git\...' using a sym-link from '%USERHOME%\git' to 'C:\SAPDevelop\git'.
        // see cap/issues/#8694
        resolvedTask.src = path.resolve(buildOptions.root, task.src)
        try {
            //validate source path
            fs.realpathSync(resolvedTask.src)
        } catch (e) {
            throw new Error(`Build task [${resolvedTask.use}] could not be resolved - folder src [${path.resolve(buildOptions.root, task.src)}] does not exist`)
        }
        resolvedTask.dest = path.resolve(buildOptions.target, task.dest || task.src)
        return resolvedTask
    }

    static _getModulePathFromTask(task) {
        let modulePath = BuildTaskHandlerFactory._getUseValueFromTask(task)
        if (!modulePath) {
            throw new Error(`Invalid build task definition - value of property 'for' or 'use' is missing.`)
        }
        if (modulePath.startsWith(BUILD_TASK_USE_PREFIX)) {
            // built-in handler
            modulePath = "./" + modulePath.substring(BUILD_TASK_USE_PREFIX.length)
        }
        return modulePath
    }

    static _getForValueFromTask(task) {
        if (task.for) {
            return task.for
        }
        return task.use && task.use.startsWith(BUILD_TASK_USE_PREFIX) ? task.use.substring(BUILD_TASK_USE_PREFIX.length) : null
    }

    static _getUseValueFromTask(task) {
        if (task.use) {
            return task.use
        }
        return task.for ? BUILD_TASK_USE_PREFIX + task.for : null
    }
}
module.exports = BuildTaskHandlerFactory
